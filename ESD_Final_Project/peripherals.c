/*
 * peripherals.c
 *
 *  Created on: May 1, 2021
 *      Author: Dhruv
 *      Brief : Contains initializations for all peripherals
 *              used.
 */
#include <msp.h>
#include "adxl345.h"
#include "peripherals.h"

/* I2C Temperature Sensor Slave Address */
#define MLX90614_I2C_ADDRESS     (0x5A)

static const unsigned char logo [] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x38, 0x38, 0x3c, 0x3c, 0x3e, 0x3e,
0x3e, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x7f, 0xff, 0xff, 0xfe, 0xfe, 0xfe, 0xfe, 0xfc, 0xfc, 0xf8, 0xf0, 0xe0, 0xc0, 0x80,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xc0,
0xc0, 0xe0, 0xe0, 0xf0, 0xf0, 0xf0, 0xf8, 0xf8, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xfc, 0xfc, 0x7c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c,
0x3c, 0xfc, 0xfc, 0xfc, 0xcc, 0xc0, 0xc0, 0xc0, 0xc0, 0xff, 0xff, 0xff, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0xff, 0xff, 0xff,
0xff, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfc, 0xfc, 0xfc, 0xf8, 0xf8, 0xf0, 0xe0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0xf3, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x01, 0x00, 0x00, 0x00, 0x30, 0x7f, 0x7f, 0x7f, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00,
0x7e, 0x7f, 0x7f, 0x07, 0x03, 0x03, 0x03, 0xe7, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xfc, 0xfc, 0xff, 0xff, 0xff,
0xff, 0x3f, 0x0f, 0x07, 0x07, 0xe3, 0xf9, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xf0, 0xf8, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfc, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x40, 0x78,
0x78, 0x78, 0x78, 0x78, 0x7c, 0x7e, 0x7f, 0x7f, 0x7f, 0x3f, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xfe, 0xfe, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x1f, 0x0f, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xe0, 0xf8, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x07, 0x07,
0x07, 0x07, 0x0f, 0x0f, 0x0f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x0f, 0x0f, 0x0f, 0x0f, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0xc0, 0xe0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff, 0xff, 0x7f, 0x3f, 0x1f, 0x0f, 0x1f, 0x3f,
0x3f, 0x3f, 0x1f, 0x1f, 0x1f, 0x0f, 0x07, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x1f, 0x7f, 0xff, 0xff, 0xff, 0x7f, 0x3f, 0x1f, 0x0f, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x1c, 0x3f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x0f, 0x07, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

void ClockSource_Init()
{
    /* Unlock CS module for register access */
    CS->KEY = CS_KEY_VAL;

    /* Reset tuning parameters */
    CS->CTL0 = 0;

    /* Set DCO to 12MHz (nominal, center of 8-16MHz range) */
    CS->CTL0 = CS_CTL0_DCORSEL_3;

    /* Select ACLK = REFO
     *        SMCLK = DCO
     *        MCLK = DCO
     */
    CS->CTL1 = CS_CTL1_SELA_2 |
               CS_CTL1_SELS_3 |
               CS_CTL1_SELM_3;

    /* Lock CS module from unintended accesses */
    CS->KEY = 0;
}

void PWM_Init()
{
    /* TA0.2 */
    P2->DIR |= BIT5;

    /* Pin Mux Settings for TA0.2 */
    P2->SEL0 |= BIT5;
    P2->SEL1 &= ~BIT5;

    /* Set Capture and Compare 0 to 10000
     * For SMCLK = 12Mhz, Period = ~8us */
    TIMER_A0->CCR[0] = 10000;

    /* Set Initial Duty Cycle = 60% */
    TIMER_A0->CCR[2] = 6000;

    /* Set Timer to SET/RESET Mode */
    TIMER_A0->CCTL[2] = TIMER_A_CCTLN_OUTMOD_6;

    /* Select SMCLK Source (12Mhz) and Count Up, Start */
    TIMER_A0->CTL = TIMER_A_CTL_TASSEL_2 |
                    TIMER_A_CTL_MC__UP |
                    TIMER_A_CTL_CLR;
}

void SysTick_Init()
{
    /* Initialize Counter Value to 0 */
    SysTick->VAL = 0;

    /* Set the LOAD Value to 4800000 for 100ms Ticks */
    SysTick->LOAD = (SYSTICK_RELOAD);

    /* Set the Control Register for Internal ClockSource (12Mhz)
     * Enable Interrupt on Overflow and Enable the Timer */
    SysTick->CTRL = (SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk);

}


/* Pin Setup for Switch Interrupt Mode */
void Switch_Init()
{
    /* Configuring Port 1 Pin 1 and Pin 4 for Switch Operation */
    P1->DIR &= ~(uint8_t) (BIT4 | BIT1);

    /* Pull-up */
    P1->OUT |= (BIT1 | BIT4);
    P1->REN |= (BIT1 | BIT4);

    /* Pin Mux for I/O */
    P1->SEL0 |= 0;
    P1->SEL1 |= 0;

    /* Interrupt on high-to-low transition */
    P1->IES |= (BIT1 | BIT4);

    /* Clear all P1 interrupt flags */
    P1->IFG = 0;

    /* Enable interrupt for P1.1 and P1.4 */
    P1->IE |= (BIT1 | BIT4);

}

void GPIO_Init()
{
    /* Manual control of Relay for debugging
     * P4.0, 4.1 F/B of Left Motor
     * P4.6, 4.7 F/B of Right Motor
     *  */

    P4->DIR |= BIT0 | BIT1 | BIT6 | BIT7;
    P4->OUT &= ~(BIT0 | BIT1 | BIT6 | BIT7);

    /* Red Indicator LED for Temperature */
    P1->DIR |= BIT0;
    P1->OUT &= ~BIT0;

    /* Red Indicator LED for Obstacle Detection */
    P2->DIR |= BIT0;
    P2->OUT &= ~BIT0;

    /* Blue "Ultraviolet" LED for Sanitization */
    P2->DIR |= BIT2;
    P2->OUT &= ~BIT2;

}

void UART_Init()
{
    /* Configure UART pins (Pin Multiplexing) */
    P1->SEL0 |= BIT2 | BIT3;

    /* Configure UART
     * Put eUSCI in reset
     * Remain eUSCI in reset
     * Configure eUSCI clock source for SMCLK
     */
    EUSCI_A0->CTLW0 |= EUSCI_A_CTLW0_SWRST;
    EUSCI_A0->CTLW0 = EUSCI_A_CTLW0_SWRST |
            EUSCI_B_CTLW0_SSEL__SMCLK;

    /* Baud Rate calculation
     * 12000000/(16*115200) = 6.5104
     * Fractional portion = 0.5104
     * User's Guide Table 21-4: UCBRSx = 0x20
     * UCBRFx = int ( (6.5104-6)*16) = 8
     */
    EUSCI_A0->BRW = 6;

    EUSCI_A0->MCTLW = (8 << EUSCI_A_MCTLW_BRF_OFS) | (0x20 << EUSCI_A_MCTLW_BRS_OFS) |
                       EUSCI_A_MCTLW_OS16;

    /* Initialize eUSCI */
    EUSCI_A0->CTLW0 &= ~EUSCI_A_CTLW0_SWRST;

    /* Clear eUSCI RX interrupt flag */
    EUSCI_A0->IFG &= ~(EUSCI_A_IFG_RXIFG);

    /* Enable USCI_A0 TX and RX interrupt */
    EUSCI_A0->IE |= (EUSCI_A_IE_RXIE | EUSCI_A_IE_TXIE);

}

void I2C_Init(){

    /* I2C pins (Pin multiplexing) */
    P6->SEL0 |= BIT4 | BIT5;

    /* Configure USCI_B0 for I2C mode
     * Software reset enabled
     * Remain eUSCI in reset mode
     * I2C mode
     * Master mode
     * Sync mode
     * SMCLK
     */
    EUSCI_B1->CTLW0 |= EUSCI_B_CTLW0_SWRST;
    EUSCI_B1->CTLW0 = EUSCI_B_CTLW0_SWRST |
                EUSCI_B_CTLW0_MODE_3 |
                EUSCI_B_CTLW0_MST |
                EUSCI_B_CTLW0_SYNC |
                EUSCI_B_CTLW0_SSEL__SMCLK;

    /* baudrate = SMCLK / 120 = 100kHz */
    EUSCI_B1->BRW = 120;

    /* Slave address (MLX 90614) */
    EUSCI_B1->I2CSA = MLX90614_I2C_ADDRESS ;

    /* Enable interrupts for Receive, Transmit and No Acknowledge */
    EUSCI_B1->IE |= EUSCI_A_IE_RXIE | EUSCI_A_IE_TXIE | EUSCI_B_IE_NACKIE ;

    /* Release eUSCI from reset */
    EUSCI_B1->CTLW0 &= ~EUSCI_B_CTLW0_SWRST;
}

void Ultrasonic_Init()
{
    /* Echo pin */
    P2->DIR &= ~BIT7;

    /* Trigger pin */
    P2->DIR |= BIT6;

    /* P2.7 Pull Down */
    P2->REN |= BIT7;

    /* P2.6, 2.7 Low initially */
    P2->OUT &= ~(BIT6 | BIT7);

    /* Pin Muxing for I/O */
    P2->SEL0 &= ~BIT7;
    P2->SEL1 &= ~BIT7;

    /* Configure rising edge interrupt for echo */
    P2->IFG = 0;
    P2->IE |= BIT7;
    P2->IES &= ~BIT7;
}

void LCD_Init()
{
    PCD8544_Init();
    PCD8544_Clear();
    DisplayBMP(logo);
}

/* Enables interrupts of all peripherals */
void Enable_Interrupts()
{
    /* Enable Port 1 interrupt on the NVIC */
    NVIC->ISER[1] = 1 << ((PORT1_IRQn) & 31);

    /* Enable eUSCIA0 interrupt in NVIC module */
    NVIC->ISER[0] = 1 << ((EUSCIA0_IRQn) & 31);

    /* Enable TA0 interrupt in NVIC module */
    NVIC->ISER[0] = 1 << ((TA0_0_IRQn) & 31);

    /* Enable Port2 interrupt in NVIC module */
    NVIC->ISER[1] = 1 << ((PORT2_IRQn) & 31);

    /* Enable eUSCIB0 interrupt in NVIC module */
    NVIC->ISER[0] = 1 << ((EUSCIB0_IRQn) & 31);

    ADXL345_Port4_Interrupt_Enable();
}

